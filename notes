--- made some fields public for convenience, fix.

# flint-sys:
- constants
- fmpz_mpoly signatures

# Inertia-core:
- matrix constructors? avoid vec<vec>. use (m, n, vec)
- differentiate hashes? intmat and intpoly both just hash vec of ints, so could have collision?
- ctx_as_ptr return ptr not ref? add as_ref fns?
- from_raw
- impl assign
- op guards
- serde (parents and poly variables)
- eq type for Arc::ptr_eq, or differentiate eq, exact eq and isomoprhism?
- polynomial init should take AsRef<String>?
- `new` constructors where applicable? Integer::new(), IntPoly::new() etc make sense. 
    IntMat::new(m, n) makes sense, but then what about IntMod::new(modulus)? FinFldElem::new(p, k)?

base: Integer, Rational, IntMod, IntPoly
conv: Integer, Rational, IntMod, IntPoly
cmp: Integer, Rational, IntMod, IntPoly
arith: Integer, Rational, IntMod, IntPoly
docs: *Integer
tests:
serde: Integer, Rational, IntMod, IntPoly

# Inertia:
- timeit macro
    - display time, suppress output, repitition, output vec of times with min/max/mean methods
    - use criterion for statistical inference?
- show macro
    - shortcut for println!("{:?}")? Maybe output command as well?
- technique+macro for aggregate timing in general. think of all the projects where we break down timing at multiple steps, aggregate in csv files and analyze later...
- see errors in openqasm crate. pretty printed errors
- use nemo benchmarks
- nicer/descriptive constants? maybe println!(ORD_LEX) outputs "Lexicographical ordering" etc
- save/load via serde
